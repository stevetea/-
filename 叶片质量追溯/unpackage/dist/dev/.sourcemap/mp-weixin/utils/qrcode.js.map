{"version":3,"file":"qrcode.js","sources":["utils/qrcode.js"],"sourcesContent":["/**\r\n * 二维码解析工具\r\n * \r\n * 简化版：二维码只存储叶片ID，扫码后通过叶片ID查询数据库获取完整信息\r\n */\r\n\r\n/**\r\n * 解析二维码内容，提取叶片ID\r\n * 支持的格式：\r\n * - B3（推荐）\r\n * - 3（纯数字）\r\n * - BLADE3（兼容旧格式）\r\n */\r\nexport function parseQRContent(qrContent) {\r\n  if (!qrContent) {\r\n    throw new Error('二维码内容为空')\r\n  }\r\n  \r\n  // 去除首尾空格和换行\r\n  const content = qrContent.trim()\r\n  \r\n  // 格式1：B3 或 B123（推荐格式）\r\n  const format1Match = content.match(/^B(\\d+)$/i)\r\n  if (format1Match) {\r\n    return {\r\n      bladeId: parseInt(format1Match[1]),\r\n      processIds: {}  // 不需要工序ID，通过叶片ID查询数据库获取\r\n    }\r\n  }\r\n  \r\n  // 格式2：纯数字 3 或 123\r\n  const format2Match = content.match(/^(\\d+)$/)\r\n  if (format2Match) {\r\n    return {\r\n      bladeId: parseInt(format2Match[1]),\r\n      processIds: {}\r\n    }\r\n  }\r\n  \r\n  // 格式3：BLADE3（兼容旧格式）\r\n  const format3Match = content.match(/^BLADE?(\\d+)$/i)\r\n  if (format3Match) {\r\n    return {\r\n      bladeId: parseInt(format3Match[1]),\r\n      processIds: {}\r\n    }\r\n  }\r\n  \r\n  // 格式4：完整格式（兼容，但不推荐）\r\n  const format4Match = content.match(/^B(\\d+)\\|P(.+)$/i)\r\n  if (format4Match) {\r\n    // 只提取叶片ID，忽略工序ID（通过数据库查询获取）\r\n    return {\r\n      bladeId: parseInt(format4Match[1]),\r\n      processIds: {}\r\n    }\r\n  }\r\n  \r\n  // 格式5：JSON格式（兼容）\r\n  try {\r\n    const data = JSON.parse(content)\r\n    if (data.b || data.bladeId) {\r\n      return {\r\n        bladeId: parseInt(data.b || data.bladeId),\r\n        processIds: {}\r\n      }\r\n    }\r\n  } catch (e) {\r\n    // JSON解析失败，继续\r\n  }\r\n  \r\n  throw new Error('无法解析二维码格式: ' + content + '。支持的格式：B3 或 3（仅叶片ID）')\r\n}\r\n\r\n/**\r\n * 生成二维码内容\r\n */\r\nexport function generateQRContent(bladeId, processIds) {\r\n  if (!bladeId || !processIds || Object.keys(processIds).length === 0) {\r\n    throw new Error('参数不完整')\r\n  }\r\n  \r\n  // 按工序顺序排序\r\n  const sortedOrders = Object.keys(processIds)\r\n    .map(Number)\r\n    .sort((a, b) => a - b)\r\n  \r\n  const processParts = sortedOrders.map(order => {\r\n    return `${order}:${processIds[order]}`\r\n  })\r\n  \r\n  return `B${bladeId}|P${processParts.join(',')}`\r\n}\r\n\r\n"],"names":[],"mappings":";AAaO,SAAS,eAAe,WAAW;AACxC,MAAI,CAAC,WAAW;AACd,UAAM,IAAI,MAAM,SAAS;AAAA,EAC1B;AAGD,QAAM,UAAU,UAAU,KAAM;AAGhC,QAAM,eAAe,QAAQ,MAAM,WAAW;AAC9C,MAAI,cAAc;AAChB,WAAO;AAAA,MACL,SAAS,SAAS,aAAa,CAAC,CAAC;AAAA,MACjC,YAAY,CAAE;AAAA;AAAA,IACf;AAAA,EACF;AAGD,QAAM,eAAe,QAAQ,MAAM,SAAS;AAC5C,MAAI,cAAc;AAChB,WAAO;AAAA,MACL,SAAS,SAAS,aAAa,CAAC,CAAC;AAAA,MACjC,YAAY,CAAE;AAAA,IACf;AAAA,EACF;AAGD,QAAM,eAAe,QAAQ,MAAM,gBAAgB;AACnD,MAAI,cAAc;AAChB,WAAO;AAAA,MACL,SAAS,SAAS,aAAa,CAAC,CAAC;AAAA,MACjC,YAAY,CAAE;AAAA,IACf;AAAA,EACF;AAGD,QAAM,eAAe,QAAQ,MAAM,kBAAkB;AACrD,MAAI,cAAc;AAEhB,WAAO;AAAA,MACL,SAAS,SAAS,aAAa,CAAC,CAAC;AAAA,MACjC,YAAY,CAAE;AAAA,IACf;AAAA,EACF;AAGD,MAAI;AACF,UAAM,OAAO,KAAK,MAAM,OAAO;AAC/B,QAAI,KAAK,KAAK,KAAK,SAAS;AAC1B,aAAO;AAAA,QACL,SAAS,SAAS,KAAK,KAAK,KAAK,OAAO;AAAA,QACxC,YAAY,CAAE;AAAA,MACf;AAAA,IACF;AAAA,EACF,SAAQ,GAAG;AAAA,EAEX;AAED,QAAM,IAAI,MAAM,gBAAgB,UAAU,sBAAsB;AAClE;;"}