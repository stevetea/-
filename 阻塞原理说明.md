# 叶片阻塞原理说明
## 一、阻塞的概念
**阻塞（BLOCKED）**是指叶片在加工过程中，某个工序执行失败，导致整个工艺流程中断的状态。阻塞状态下，叶片无法继续进入下一道工序，需要先解决当前工序的问题（返工或修复）后才能继续。
## 二、阻塞的触发条件
阻塞在以下情况下自动触发：
1. **工序录入失败**：操作员在录入工序时，选择"失败"（`is_success = 0`）
2. **必须填写失败原因**：失败时必须填写失败原因（`fail_reason`），否则无法提交
## 三、阻塞的实现机制
### 1. 数据库层面
系统使用两个表来管理阻塞状态：
#### 1.1 `blade` 表（叶片主表）
- **字段**：`status`
- **阻塞时值**：`'BLOCKED'`
- **作用**：标识叶片的整体状态
#### 1.2 `blade_process_state` 表（工序状态表）
- **字段**：
  - `is_blocked`：是否阻塞（1=阻塞，0=正常）
  - `blocked_order`：阻塞发生的工序顺序号
  - `blocked_code`：阻塞发生的工序编码
  - `blocked_reason`：阻塞原因（即失败原因）
  - `current_success_order`：最后成功完成的工序顺序号
- **作用**：详细记录阻塞信息，便于追溯和返工
### 2. 代码实现（后端）
位置：`backend/routes/process.js`
#### 2.1 工序失败时的处理逻辑
```javascript
// 当 is_success = 0（失败）时
if (!is_success) {
  // 1. 更新叶片状态为阻塞
  await pool.execute(
    'UPDATE blade SET status = ? WHERE blade_id = ?',
    ['BLOCKED', blade_id]
  );
  // 2. 更新工序状态表，记录阻塞信息
  await pool.execute(
    `INSERT INTO blade_process_state (
      blade_id, 
      current_success_order,  // 当前成功完成的工序顺序号（失败工序的前一个）
      last_process_code,      // 最后记录的工序编码
      is_blocked,             // 设置为1（阻塞）
      blocked_order,          // 阻塞发生的工序顺序号
      blocked_code,           // 阻塞发生的工序编码
      blocked_reason,         // 阻塞原因（失败原因）
      updated_at
    ) VALUES (?, ?, ?, 1, ?, ?, ?, NOW())
    ON DUPLICATE KEY UPDATE 
      is_blocked = 1,
      blocked_order = ?,
      blocked_code = ?,
      blocked_reason = ?,
      updated_at = NOW()`,
    [
      blade_id, 
      processDef.process_order - 1,  // 失败工序的前一个顺序号
      processDef.process_code,        // 当前工序编码
      processDef.process_order,       // 阻塞发生的顺序号
      process_code,                   // 阻塞发生的工序编码
      fail_reason || '工序失败',      // 阻塞原因
      // 更新时的参数
      processDef.process_order,
      process_code,
      fail_reason || '工序失败'
    ]
  );
}
```

#### 2.2 工序成功时的处理逻辑

```javascript
// 当 is_success = 1（成功）时
if (is_success) {
  // 1. 更新叶片状态为加工中
  await pool.execute(
    'UPDATE blade SET status = ? WHERE blade_id = ?',
    ['IN_PROCESS', blade_id]
  );
  
  // 2. 更新工序状态表，清除阻塞状态
  await pool.execute(
    `INSERT INTO blade_process_state (
      blade_id,
      current_success_order,  // 当前成功完成的工序顺序号
      last_process_code,    // 最后记录的工序编码
      is_blocked,             // 设置为0（正常）
      updated_at
    ) VALUES (?, ?, ?, 0, NOW())
    ON DUPLICATE KEY UPDATE 
      current_success_order = ?,
      last_process_code = ?,
      is_blocked = 0,        // 清除阻塞状态
      updated_at = NOW()`,
    [
      blade_id,
      processDef.process_order,  // 当前工序顺序号
      process_code,              // 当前工序编码
      processDef.process_order,
      process_code
    ]
  );
}
```

## 四、阻塞的解除机制

### 1. 自动解除

当操作员对**阻塞的工序**进行**返工**（重新录入该工序）并**成功**时：

1. 系统检测到该工序再次录入且成功
2. 自动将 `is_blocked` 设置为 0
3. 将叶片状态从 `BLOCKED` 更新为 `IN_PROCESS`
4. 更新 `current_success_order` 为当前工序顺序号
5. 清除阻塞相关字段（`blocked_order`、`blocked_code`、`blocked_reason`）

### 2. 返工流程

1. **操作员扫描叶片二维码** → 查看追溯信息
2. **发现阻塞状态** → 查看阻塞原因和阻塞工序
3. **重新执行阻塞工序** → 在工序录入页面选择该工序
4. **录入成功** → 系统自动解除阻塞，继续流程

## 五、阻塞信息查询

### 1. 追溯详情接口

通过 `GET /api/blade/:bladeId/trace` 接口可以查询：

```json
{
  "blade": {
    "blade_id": 8,
    "blade_sn": "SN-20251228-0008",
    "status": "BLOCKED"
  },
  "state": {
    "blade_id": 8,
    "current_success_order": 3,        // 最后成功完成到第3步
    "last_process_code": "EDGE_GRIND",
    "is_blocked": 1,                   // 阻塞中
    "blocked_order": 4,                // 阻塞在第4步
    "blocked_code": "CERAMIC_COAT_HEAT", // 阻塞工序：涂陶瓷漆涂层加热
    "blocked_reason": "涂层厚度不达标"   // 阻塞原因
  },
  "processes": [
    // 工序列表，包含每个工序的执行记录
  ]
}
```

### 2. 前端显示

- **叶片列表**：阻塞的叶片显示为红色/橙色标识
- **追溯详情**：显示阻塞工序、阻塞原因
- **数据统计**：统计阻塞叶片数量

## 六、阻塞的业务意义

1. **质量控制**：确保不合格的叶片不会进入下一道工序
2. **问题追溯**：记录失败原因，便于分析问题
3. **流程管理**：明确标识需要处理的叶片
4. **返工指导**：通过阻塞信息指导操作员进行返工

## 七、示例场景

### 场景1：第4步工序失败

1. 叶片已完成前3步工序（合金预热、冲压成型冷却、打磨边缘）
2. 第4步"涂陶瓷漆涂层加热"执行失败，失败原因："涂层厚度不达标"
3. 系统自动：
   - 将叶片状态设置为 `BLOCKED`
   - 记录 `blocked_order = 4`、`blocked_code = 'CERAMIC_COAT_HEAT'`
   - 记录 `blocked_reason = '涂层厚度不达标'`
   - 保持 `current_success_order = 3`（最后成功完成到第3步）

### 场景2：返工成功解除阻塞

1. 操作员重新执行第4步"涂陶瓷漆涂层加热"
2. 本次执行成功
3. 系统自动：
   - 将叶片状态从 `BLOCKED` 更新为 `IN_PROCESS`
   - 将 `is_blocked` 设置为 0
   - 更新 `current_success_order = 4`
   - 清除阻塞相关字段
4. 叶片可以继续进入第5步工序

## 八、关键代码位置

- **后端阻塞逻辑**：`backend/routes/process.js` 第141-159行
- **数据库表结构**：`traceability_schema.sql` 第75-86行
- **前端状态显示**：`pages/trace-detail/trace-detail.vue`
- **状态映射**：`utils/config.js` 第30行

## 九、注意事项

1. **阻塞是自动的**：系统根据工序录入结果自动设置，无需手动操作
2. **必须填写失败原因**：失败时必须填写 `fail_reason`，否则无法提交
3. **返工需重新录入**：解除阻塞需要操作员重新录入该工序并成功
4. **阻塞信息持久化**：阻塞信息保存在 `blade_process_state` 表中，便于追溯

