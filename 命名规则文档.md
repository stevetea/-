# 命名规则文档

本文档定义了项目中变量对象和数据库对象的命名规则，确保代码风格统一、可读性强、易于维护。

---

## 一、变量对象命名规则

### 1.1 全局变量

**规则：使用 UPPER_SNAKE_CASE（全大写，单词间用下划线分隔）**

**适用场景：**
- 全局常量
- 配置项
- 环境变量
- 模块级常量

**示例：**
```javascript
// 端口配置
const PORT = process.env.PORT || 3000;

// 模型路径
const MODEL_PATH = path.join(__dirname, '../../best.pt');

// API配置
const API_BASE_URL = 'http://localhost:3000/api';

// 状态映射常量
export const BLADE_STATUS_MAP = {
  NEW: '新建',
  IN_PROCESS: '加工中',
  BLOCKED: '阻塞'
};
```

**注意事项：**
- 全局变量必须使用 `const` 声明，避免意外修改
- 如果需要在运行时修改，应使用配置对象而非直接变量

---

### 1.2 局部变量

**规则：使用 camelCase（驼峰命名，首字母小写）**

**适用场景：**
- 函数内变量
- 函数参数
- 循环变量
- 临时变量
- 对象属性（JavaScript对象）

**示例：**
```javascript
// 函数参数
async function getUserInfo(userId, operatorId) {
  // 局部变量
  const limit = parseInt(req.query.limit) || 10;
  const offset = parseInt(req.query.offset) || 0;
  const bladeId = req.params.bladeId;
  
  // 对象解构
  const { blade_sn, status } = req.body;
  
  // 数组/对象
  const bladeList = [];
  const statusOptions = [
    { value: 'NEW', label: '新建' }
  ];
  
  // 布尔值
  const isLoading = false;
  const isSuccess = true;
  
  // 循环变量
  for (let i = 0; i < records.length; i++) {
    const record = records[i];
  }
}
```

**命名建议：**
- **布尔值变量**：使用 `is`、`has`、`can`、`should` 等前缀
  - `isLoading`, `hasPermission`, `canEdit`, `shouldRetry`
- **数组变量**：使用复数形式或 `List`、`Array` 后缀
  - `bladeList`, `userList`, `records`, `items`
- **函数变量**：使用动词开头
  - `getUserInfo`, `loadBladeList`, `formatTime`
- **对象变量**：使用名词
  - `userInfo`, `bladeData`, `config`

---

### 1.3 函数命名

**规则：使用 camelCase（驼峰命名，首字母小写）**

**命名模式：**
- **获取数据**：`get` + 名词（如 `getUserInfo`, `getBladeList`）
- **创建数据**：`create` + 名词（如 `createBlade`, `createUser`）
- **更新数据**：`update` + 名词（如 `updateBlade`, `updateStatus`）
- **删除数据**：`delete` + 名词 或 `remove` + 名词（如 `deleteBlade`, `removeUser`）
- **检查/验证**：`check` + 名词（如 `checkPermission`, `checkRole`）
- **格式化**：`format` + 名词（如 `formatTime`, `formatDate`）
- **处理/处理**：`handle` + 名词（如 `handleSubmit`, `handleError`）

**示例：**
```javascript
// 后端路由函数
async function getUserInfo(userId) { }
async function createBlade(bladeData) { }
async function updateBladeStatus(bladeId, status) { }

// 前端方法
methods: {
  loadBladeList() { },
  formatTime(timestamp) { },
  onStatusChange(e) { },
  viewTrace(bladeId) { }
}
```

---

### 1.4 类命名

**规则：使用 PascalCase（大驼峰命名，首字母大写）**

**示例：**
```javascript
class UserService { }
class BladeController { }
class DatabaseConnection { }
```

---

### 1.5 私有变量/方法

**规则：使用下划线前缀 `_` + camelCase**

**示例：**
```javascript
class UserService {
  constructor() {
    this._internalCache = {};
  }
  
  _validateInput(data) {
    // 私有方法
  }
  
  _formatResponse(result) {
    // 私有方法
  }
}
```

---

## 二、数据库对象命名规则

### 2.1 表名（Table Name）

**规则：使用 snake_case（全小写，单词间用下划线分隔）**

**命名规范：**
- 使用单数形式（推荐）或复数形式（需统一）
- 表名应简洁、有意义
- 避免使用数据库关键字

**示例：**
```sql
-- 主数据表
CREATE TABLE blade (...);
CREATE TABLE operator_user (...);

-- 工序表（使用 proc_ 前缀）
CREATE TABLE proc_alloy_preheat (...);
CREATE TABLE proc_stamp_form_cool (...);
CREATE TABLE proc_edge_grind (...);

-- 质检表（使用 qc_ 前缀）
CREATE TABLE qc_inspection (...);

-- 配置表
CREATE TABLE process_def (...);
CREATE TABLE blade_process_state (...);

-- 认证表
CREATE TABLE auth_account (...);
```

**表名前缀约定：**
- `proc_`：工序表（process）
- `qc_`：质检表（quality control）
- `auth_`：认证相关表
- 主数据表：无前缀

---

### 2.2 字段名（Column Name）

**规则：使用 snake_case（全小写，单词间用下划线分隔）**

**命名规范：**
- 主键：`表名单数_id`（如 `blade_id`, `operator_id`）
- 外键：`关联表名_id`（如 `blade_id`, `operator_id`）
- 布尔字段：`is_` + 描述（如 `is_success`, `is_active`, `is_blocked`）
- 时间字段：`动作_at` 或 `动作_time`（如 `created_at`, `updated_at`, `performed_at`）
- 状态字段：`status` 或 `状态名`（如 `status`, `result`）
- 数量字段：`数量_单位`（如 `hold_time_min`, `cooling_time_s`）

**示例：**
```sql
CREATE TABLE blade (
    blade_id BIGINT UNSIGNED PRIMARY KEY AUTO_INCREMENT,
    blade_sn VARCHAR(64) NOT NULL,
    status ENUM('NEW','IN_PROCESS','BLOCKED') NOT NULL,
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
);

CREATE TABLE proc_alloy_preheat (
    id BIGINT UNSIGNED PRIMARY KEY AUTO_INCREMENT,
    blade_id BIGINT UNSIGNED NOT NULL,
    operator_id BIGINT UNSIGNED NOT NULL,
    performed_at DATETIME NOT NULL,
    is_success TINYINT(1) NOT NULL,
    fail_reason VARCHAR(255) NULL,
    attempt_no SMALLINT UNSIGNED NOT NULL DEFAULT 1
);
```

**字段命名建议：**
- **主键**：统一使用 `表名_id` 格式
- **序列号/编号**：使用 `_sn`（serial number）或 `_no`（number）后缀
  - `blade_sn`, `furnace_no`, `press_no`
- **批次号**：使用 `_batch_no` 后缀
  - `paint_batch_no`, `alloy_batch_no`
- **时间字段**：
  - `created_at`：创建时间
  - `updated_at`：更新时间
  - `performed_at`：执行时间
  - `inspected_at`：检查时间
- **布尔字段**：统一使用 `is_` 前缀
  - `is_success`, `is_active`, `is_blocked`, `is_qc`

---

### 2.3 索引名（Index Name）

**规则：使用前缀 + snake_case**

**索引命名规范：**
- **普通索引**：`idx_` + 字段名（多个字段用下划线连接）
- **唯一索引**：`uk_` + 字段名（unique key）
- **主键索引**：通常由数据库自动生成，无需手动命名

**示例：**
```sql
-- 普通索引
KEY idx_blade_time (blade_id, performed_at),
KEY idx_operator_time (operator_id, performed_at),
KEY idx_status_updated (status, updated_at),
KEY idx_blocked (is_blocked, blocked_order)

-- 唯一索引
UNIQUE KEY uk_blade_sn (blade_sn),
UNIQUE KEY uk_blade_attempt (blade_id, attempt_no),
UNIQUE KEY uk_process_order (process_order),
UNIQUE KEY uk_table_name (table_name),
UNIQUE KEY uk_qr_text (qr_text)
```

**索引命名建议：**
- 索引名应反映索引的用途和字段
- 复合索引按字段重要性排序
- 唯一索引使用 `uk_` 前缀便于识别

---

### 2.4 外键名（Foreign Key Name）

**规则：使用 `fk_` 前缀 + 简短描述**

**命名规范：**
- 格式：`fk_` + 简短标识 + `_` + 关联表名
- 简短标识可以是表名缩写或序号

**示例：**
```sql
-- 工序表外键（使用序号区分）
CONSTRAINT fk_p1_blade FOREIGN KEY (blade_id) REFERENCES blade(blade_id),
CONSTRAINT fk_p1_operator FOREIGN KEY (operator_id) REFERENCES operator_user(operator_id),
CONSTRAINT fk_p2_blade FOREIGN KEY (blade_id) REFERENCES blade(blade_id),
CONSTRAINT fk_p2_operator FOREIGN KEY (operator_id) REFERENCES operator_user(operator_id),

-- 状态表外键
CONSTRAINT fk_state_blade FOREIGN KEY (blade_id) REFERENCES blade(blade_id),

-- 质检表外键
CONSTRAINT fk_qc_blade FOREIGN KEY (blade_id) REFERENCES blade(blade_id),
CONSTRAINT fk_qc_inspector FOREIGN KEY (inspector_id) REFERENCES operator_user(operator_id),

-- 认证表外键
CONSTRAINT fk_auth_operator FOREIGN KEY (operator_id) REFERENCES operator_user(operator_id)
```

**外键命名建议：**
- 使用有意义的标识符，避免仅使用数字
- 如果多个表有相同的外键关系，使用序号或表名缩写区分

---

### 2.5 视图名（View Name）

**规则：使用 `v_` 前缀 + snake_case**

**示例：**
```sql
CREATE VIEW v_blade_summary AS
SELECT 
    b.blade_id,
    b.blade_sn,
    b.status,
    COUNT(p.id) as process_count
FROM blade b
LEFT JOIN proc_alloy_preheat p ON b.blade_id = p.blade_id
GROUP BY b.blade_id;

CREATE VIEW v_operator_statistics AS
SELECT 
    o.operator_id,
    o.operator_name,
    COUNT(DISTINCT p.blade_id) as blade_count
FROM operator_user o
LEFT JOIN proc_alloy_preheat p ON o.operator_id = p.operator_id
GROUP BY o.operator_id;
```

**视图命名建议：**
- 使用 `v_` 前缀便于识别视图
- 视图名应描述视图的用途

---

### 2.6 存储过程名（Stored Procedure Name）

**规则：使用 `sp_` 前缀 + snake_case**

**示例：**
```sql
CREATE PROCEDURE sp_update_blade_status(
    IN p_blade_id BIGINT,
    IN p_status VARCHAR(20)
)
BEGIN
    UPDATE blade 
    SET status = p_status, updated_at = NOW()
    WHERE blade_id = p_blade_id;
END;
```

**存储过程命名建议：**
- 使用 `sp_` 前缀便于识别存储过程
- 参数使用 `p_` 前缀区分

---

### 2.7 触发器名（Trigger Name）

**规则：使用 `trg_` 前缀 + 表名 + `_` + 动作**

**示例：**
```sql
CREATE TRIGGER trg_blade_after_insert
AFTER INSERT ON blade
FOR EACH ROW
BEGIN
    INSERT INTO blade_process_state (blade_id, current_success_order)
    VALUES (NEW.blade_id, 0);
END;

CREATE TRIGGER trg_blade_after_update
AFTER UPDATE ON blade
FOR EACH ROW
BEGIN
    -- 触发器逻辑
END;
```

**触发器命名建议：**
- 使用 `trg_` 前缀便于识别触发器
- 包含表名和触发时机（before/after）和动作（insert/update/delete）

---

## 三、命名规则总结表

| 对象类型 | 命名规则 | 示例 |
|---------|---------|------|
| **全局变量/常量** | UPPER_SNAKE_CASE | `PORT`, `API_BASE_URL` |
| **局部变量** | camelCase | `userId`, `bladeList`, `isLoading` |
| **函数名** | camelCase | `getUserInfo`, `loadBladeList` |
| **类名** | PascalCase | `UserService`, `BladeController` |
| **私有变量/方法** | `_` + camelCase | `_internalCache`, `_validateInput` |
| **数据库表名** | snake_case | `blade`, `operator_user`, `proc_alloy_preheat` |
| **数据库字段名** | snake_case | `blade_id`, `is_success`, `created_at` |
| **普通索引** | `idx_` + snake_case | `idx_blade_time`, `idx_status_updated` |
| **唯一索引** | `uk_` + snake_case | `uk_blade_sn`, `uk_blade_attempt` |
| **外键** | `fk_` + 描述 | `fk_p1_blade`, `fk_qc_inspector` |
| **视图** | `v_` + snake_case | `v_blade_summary` |
| **存储过程** | `sp_` + snake_case | `sp_update_blade_status` |
| **触发器** | `trg_` + 表名 + 动作 | `trg_blade_after_insert` |

---

## 四、命名规则检查清单

在编写代码时，请遵循以下检查清单：

### 变量命名
- [ ] 全局常量使用 UPPER_SNAKE_CASE
- [ ] 局部变量使用 camelCase
- [ ] 布尔变量使用 `is`/`has`/`can` 前缀
- [ ] 数组变量使用复数形式或 `List` 后缀
- [ ] 函数名使用动词开头

### 数据库命名
- [ ] 表名使用 snake_case
- [ ] 字段名使用 snake_case
- [ ] 主键统一使用 `表名_id` 格式
- [ ] 布尔字段使用 `is_` 前缀
- [ ] 时间字段使用 `_at` 或 `_time` 后缀
- [ ] 索引使用 `idx_` 或 `uk_` 前缀
- [ ] 外键使用 `fk_` 前缀

---

## 五、常见错误示例

### ❌ 错误示例

```javascript
// 错误：全局变量使用 camelCase
const port = 3000;

// 错误：局部变量使用 UPPER_CASE
const USER_ID = req.user.id;

// 错误：函数名使用下划线
function get_user_info() { }

// 错误：布尔变量不使用前缀
const loading = false;  // 应使用 isLoading
```

```sql
-- 错误：表名使用驼峰命名
CREATE TABLE BladeInfo (...);

-- 错误：字段名使用驼峰命名
CREATE TABLE blade (
    bladeId BIGINT,  -- 应使用 blade_id
    isSuccess TINYINT  -- 应使用 is_success
);

-- 错误：索引名不使用前缀
KEY blade_time (blade_id, performed_at);  -- 应使用 idx_blade_time
```

### ✅ 正确示例

```javascript
// 正确：全局常量
const PORT = 3000;

// 正确：局部变量
const userId = req.user.id;
const isLoading = false;

// 正确：函数名
function getUserInfo() { }
```

```sql
-- 正确：表名和字段名
CREATE TABLE blade (
    blade_id BIGINT,
    is_success TINYINT
);

-- 正确：索引名
KEY idx_blade_time (blade_id, performed_at);
```

---

## 六、注意事项

1. **一致性**：在整个项目中保持命名风格一致
2. **可读性**：命名应清晰表达变量或对象的用途
3. **避免缩写**：除非是广泛认知的缩写（如 `id`, `sn`, `qc`），否则使用完整单词
4. **避免关键字**：不要使用编程语言或数据库的关键字作为变量名或表名
5. **长度适中**：命名既不能太短（难以理解），也不能太长（影响可读性）

---

**文档版本：** 1.0  
**最后更新：** 2024-12-27  
**维护者：** 开发团队

